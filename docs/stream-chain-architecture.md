# Stream-Chain Architecture

> Generated by SPARC Documenter Mode | 2026-02-26

## Overview

Stream-chain is a sequential multi-agent prompt pipeline system built on `claude-flow`. It executes ordered steps where each step's output feeds into the next, enabling deep on-demand analysis that complements the existing Loki RARV workflow and periodic daemon workers.

## System Architecture

```
scripts/stream-chain-run.sh          CLI entry point
        |
        v
.claude-flow/config.json             Pipeline definitions (6 pipelines)
        |
        v
npx claude-flow stream-chain run     Execution engine (claude-flow MCP)
        |
        +---> .claude-flow/memory/stream-chain/runs/   Result storage
        |         ├── <pipeline>-<timestamp>.json       Summary
        |         └── <pipeline>-<timestamp>-output.log Full output
        |
        +---> .loki/events/pending/                    Loki event bus
                  └── stream-chain-<run-id>.json        task_complete event
                          |
                          v
                  loki-event-sync.sh                   Board sync + memory persist
```

## Component Roles

### Config (`config.json`)

Central registry of pipeline definitions. Each pipeline has:
- `description` — human-readable purpose
- `timeout` — per-step timeout in seconds (falls back to `streamChain.defaultTimeout`)
- `steps[]` — ordered array of `{ name, prompt }` objects

The config is NOT gittracked (lives inside `.claude-flow/` which is gitignored).

### Wrapper Script (`stream-chain-run.sh`)

Bridges the JSON config to the `claude-flow stream-chain` CLI:
1. Parses the config via inline Python (`python3 -c`)
2. Extracts the prompt array and timeout for the requested pipeline
3. Builds and invokes `npx claude-flow stream-chain run <prompts> --timeout N`
4. Captures timing, exit code, and writes a structured result JSON
5. Emits a Loki `task_complete` event for downstream board sync

### Result Storage (`memory/stream-chain/runs/`)

Each run produces two files:
- `<pipeline>-<YYYYMMDD-HHMMSS>.json` — structured metadata (runId, status, duration, exit code)
- `<pipeline>-<YYYYMMDD-HHMMSS>-output.log` — raw CLI output

### Loki Integration

Events land in `.loki/events/pending/` using the existing `task_complete` type. The `loki-event-sync.sh` hook (already operational) picks these up and triggers:
- GitHub Projects #4 board sync
- Notion roadmap sync
- Claude-flow memory persistence

## Relationship to Existing Systems

| System | Role | Trigger |
|--------|------|---------|
| **Stream-chain** | On-demand deep analysis pipelines | Manual (`scripts/stream-chain-run.sh`) |
| **Daemon workers** | Periodic lightweight checks (audit, testgaps, optimize) | Automatic (timer-based, `daemon-state.json`) |
| **YAML workflows** | Agent-based orchestration (nightly-learning, price-pipeline) | Scheduled / event-driven |
| **loki-feature.sh** | Full PRD-to-PR feature development | Manual (PRD input) |
| **loki-verify.sh** | Test/lint/coverage verification gate | Called by loki-feature or standalone |

Stream-chain pipelines are **complementary** — they don't replace any existing system. They provide deeper, multi-step analysis that daemon workers (single-pass, lightweight) don't cover.

## Pipeline Inventory

| Pipeline | Steps | Timeout/step | Use Case |
|----------|-------|-------------|----------|
| `test` | 4 | 120s | Full test suite + gap analysis across all 3 test layers |
| `security` | 4 | 60s | OWASP audit + dependency + secrets scan + adversarial tests |
| `refactor` | 3 | 45s | Complexity scan + tech debt inventory + prioritized plan |
| `feature-tdd` | 4 | 90s | TDD cycle: spec, failing tests, implement, verify |
| `deploy-check` | 4 | 60s | Pre-deploy gate: tests, config, migrations, prod readiness |
| `analysis` | 3 | 45s | Architecture map + dependency analysis + debt report |

## Data Flow

```
User invokes:  scripts/stream-chain-run.sh security

  1. Bash parses flags (--dry-run, --bg, --verbose)
  2. Python extracts pipeline "security" from config.json
  3. Returns: timeout=60, prompts=[owasp-audit, dependency-scan, secrets-scan, adversarial-tests]
  4. Builds CLI: npx claude-flow stream-chain run "prompt1" "prompt2" "prompt3" "prompt4" --timeout 60
  5. stream-chain executes steps sequentially, piping context forward
  6. On completion:
     a. Writes result JSON to runs/security-20260226-143022.json
     b. Writes raw output to runs/security-20260226-143022-output.log
     c. Emits task_complete event to .loki/events/pending/
  7. loki-event-sync.sh picks up event -> board sync + memory persist
```

## Error Handling

- **Missing config**: Script exits with error message and code 1
- **Invalid pipeline name**: Python extraction fails with available names listed
- **CLI failure**: Non-zero exit code captured; result JSON records `"status": "failed"`
- **Loki event always emitted**: Both success and failure produce events for observability
- **Background mode**: Failures are logged but don't block the shell

## Security Considerations

- Config file lives in gitignored `.claude-flow/` — no secrets leak to git
- Prompts reference absolute paths (project-local) — no path traversal risk
- Python inline execution is read-only JSON parsing — no code injection surface
- Result files are local-only (gitignored directory)
