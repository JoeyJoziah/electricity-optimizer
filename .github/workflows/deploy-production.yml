name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., v1.0.0)'
        required: true
        type: string
      skip_tests:
        description: 'Skip tests before deployment'
        required: false
        default: false
        type: boolean

concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE: ${{ github.repository }}/backend
  FRONTEND_IMAGE: ${{ github.repository }}/frontend

jobs:
  # ===========================================================================
  # Validate Release
  # ===========================================================================
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    timeout-minutes: 5

    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

  # ===========================================================================
  # Run Tests (reusable workflow)
  # ===========================================================================
  test:
    name: Run Tests
    needs: [validate]
    if: github.event.inputs.skip_tests != 'true'
    uses: ./.github/workflows/_backend-tests.yml
    with:
      coverage: false
      upload-codecov: false

  # ===========================================================================
  # Security Gate (blocking — must pass before deploy)
  # ===========================================================================
  security-gate:
    name: Security Gate
    runs-on: ubuntu-latest
    needs: [validate]
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Bandit high-severity check
        run: |
          pip install bandit
          cd backend
          # Fail on high-severity issues (exit code non-zero)
          bandit -r . -ll --severity-level high -f txt
          echo "Backend security scan passed"

      - name: npm audit critical check
        run: |
          cd frontend
          npm audit --audit-level=critical
          echo "Frontend security audit passed"

  # ===========================================================================
  # Build and Push Images (archival — Render builds from repo)
  # ===========================================================================
  build-backend:
    name: Build Backend Image
    needs: [validate, test, security-gate]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped') && needs.security-gate.result == 'success'
    uses: ./.github/workflows/_docker-build-push.yml
    with:
      context: ./backend
      dockerfile: ./backend/Dockerfile
      image-name: ghcr.io/${{ github.repository }}/backend
      tags: |
        type=raw,value=latest
        type=raw,value=${{ needs.validate.outputs.version }}
        type=sha,prefix=
      push: true

  build-frontend:
    name: Build Frontend Image
    needs: [validate, test, security-gate]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped') && needs.security-gate.result == 'success'
    uses: ./.github/workflows/_docker-build-push.yml
    with:
      context: ./frontend
      dockerfile: ./frontend/Dockerfile
      image-name: ghcr.io/${{ github.repository }}/frontend
      tags: |
        type=raw,value=latest
        type=raw,value=${{ needs.validate.outputs.version }}
        type=sha,prefix=
      build-args: NEXT_PUBLIC_API_URL=${{ vars.PROD_API_URL }}
      push: true

  # ===========================================================================
  # Deploy to Render
  # ===========================================================================
  deploy:
    name: Deploy to Render
    runs-on: ubuntu-latest
    needs: [validate, build-backend, build-frontend]
    timeout-minutes: 15
    environment:
      name: production
      url: https://electricity-optimizer.com

    steps:
      - name: Trigger Render backend deploy
        run: |
          echo "Triggering Render backend deploy..."
          curl -fsS -X POST "${{ secrets.RENDER_DEPLOY_HOOK_BACKEND }}" || {
            echo "::error::Failed to trigger backend deploy hook"
            exit 1
          }
          echo "Backend deploy hook triggered"

      - name: Trigger Render frontend deploy
        run: |
          echo "Triggering Render frontend deploy..."
          curl -fsS -X POST "${{ secrets.RENDER_DEPLOY_HOOK_FRONTEND }}" || {
            echo "::error::Failed to trigger frontend deploy hook"
            exit 1
          }
          echo "Frontend deploy hook triggered"

  # ===========================================================================
  # Smoke Tests with Self-Healing
  # ===========================================================================
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy]
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4

      - name: Wait for backend
        uses: ./.github/actions/wait-for-service
        with:
          url: ${{ secrets.PROD_API_URL }}/health
          timeout: '300'
          interval: '15'

      - name: Wait for frontend
        uses: ./.github/actions/wait-for-service
        with:
          url: ${{ secrets.PROD_FRONTEND_URL }}
          timeout: '300'
          interval: '15'

      - name: Verify API endpoints
        id: smoke
        run: |
          FAILURES=0
          for endpoint in /health /api/v1/prices/current; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.PROD_API_URL }}${endpoint}" 2>/dev/null) || STATUS="000"
            if [ "$STATUS" != "200" ] && [ "$STATUS" != "401" ]; then
              echo "FAIL: ${endpoint} returned ${STATUS}"
              FAILURES=$((FAILURES + 1))
            else
              echo "OK: ${endpoint} returned ${STATUS}"
            fi
          done
          echo "failures=$FAILURES" >> $GITHUB_OUTPUT

      - name: Auto-retry deploy on failure
        if: steps.smoke.outputs.failures != '0'
        run: |
          echo "::warning::Smoke tests failed (${{ steps.smoke.outputs.failures }} failures). Triggering re-deploy..."
          curl -s -X POST "${{ secrets.RENDER_DEPLOY_HOOK_BACKEND }}" || true
          curl -s -X POST "${{ secrets.RENDER_DEPLOY_HOOK_FRONTEND }}" || true

      - name: Wait for re-deploy
        if: steps.smoke.outputs.failures != '0'
        uses: ./.github/actions/wait-for-service
        with:
          url: ${{ secrets.PROD_API_URL }}/health
          timeout: '300'
          interval: '15'

      - name: Final verification
        if: steps.smoke.outputs.failures != '0'
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.PROD_API_URL }}/health" 2>/dev/null) || STATUS="000"
          if [ "$STATUS" != "200" ]; then
            echo "::error::Backend still unhealthy after re-deploy (HTTP $STATUS)"
            exit 1
          fi
          echo "Backend recovered after re-deploy"

  # ===========================================================================
  # Rollback on Failure
  #
  # Triggered when smoke-tests fails (meaning the live deployment did not
  # recover after a self-healing retry).
  #
  # Strategy:
  #   1. Use the Render REST API to find the most-recent *successful* deploy
  #      for each service that predates the current run.
  #   2. Re-trigger that deploy via POST /deploys/:id/rollback so Render
  #      rebuilds the previously-known-good image without a new commit push.
  #
  # Required secrets:
  #   RENDER_API_KEY  – Render personal API token (Settings → API Keys)
  #
  # Render service IDs are hard-coded from the project's known configuration:
  #   Backend  srv-d649uhur433s73d557cg
  #   Frontend srv-d64ebangi27c73avv6d0
  # ===========================================================================
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [validate, smoke-tests]
    if: failure()
    timeout-minutes: 10

    env:
      RENDER_API_BASE: https://api.render.com/v1
      BACKEND_SERVICE_ID: srv-d649uhur433s73d557cg
      FRONTEND_SERVICE_ID: srv-d64ebangi27c73avv6d0

    steps:
      - name: Announce rollback intent
        run: |
          echo "::error::Production smoke tests failed after self-healing retry."
          echo "Version attempted: ${{ needs.validate.outputs.version }}"
          echo "Initiating automated rollback to last known-good deploy..."

      # -----------------------------------------------------------------------
      # Backend rollback
      # -----------------------------------------------------------------------
      - name: Fetch last successful backend deploy ID
        id: last-backend-deploy
        run: |
          # List the 10 most-recent deploys for this service, then pick the
          # first one whose status is "live" (completed successfully).
          DEPLOY_ID=$(curl -fsS \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Accept: application/json" \
            "${RENDER_API_BASE}/services/${BACKEND_SERVICE_ID}/deploys?limit=10" \
            | jq -r '[.[] | select(.deploy.status == "live")] | .[0].deploy.id // empty')

          if [ -z "$DEPLOY_ID" ]; then
            echo "::error::No previous successful backend deploy found. Manual rollback required."
            exit 1
          fi

          echo "Last successful backend deploy: $DEPLOY_ID"
          echo "deploy_id=$DEPLOY_ID" >> $GITHUB_OUTPUT

      - name: Rollback backend to last successful deploy
        run: |
          DEPLOY_ID="${{ steps.last-backend-deploy.outputs.deploy_id }}"
          echo "Rolling backend back to deploy $DEPLOY_ID ..."
          RESPONSE=$(curl -fsS -X POST \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            "${RENDER_API_BASE}/services/${BACKEND_SERVICE_ID}/deploys/${DEPLOY_ID}/rollback")
          echo "Render rollback response: $RESPONSE"
          echo "Backend rollback triggered."

      # -----------------------------------------------------------------------
      # Frontend rollback
      # -----------------------------------------------------------------------
      - name: Fetch last successful frontend deploy ID
        id: last-frontend-deploy
        run: |
          DEPLOY_ID=$(curl -fsS \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Accept: application/json" \
            "${RENDER_API_BASE}/services/${FRONTEND_SERVICE_ID}/deploys?limit=10" \
            | jq -r '[.[] | select(.deploy.status == "live")] | .[0].deploy.id // empty')

          if [ -z "$DEPLOY_ID" ]; then
            echo "::error::No previous successful frontend deploy found. Manual rollback required."
            exit 1
          fi

          echo "Last successful frontend deploy: $DEPLOY_ID"
          echo "deploy_id=$DEPLOY_ID" >> $GITHUB_OUTPUT

      - name: Rollback frontend to last successful deploy
        run: |
          DEPLOY_ID="${{ steps.last-frontend-deploy.outputs.deploy_id }}"
          echo "Rolling frontend back to deploy $DEPLOY_ID ..."
          RESPONSE=$(curl -fsS -X POST \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            "${RENDER_API_BASE}/services/${FRONTEND_SERVICE_ID}/deploys/${DEPLOY_ID}/rollback")
          echo "Render rollback response: $RESPONSE"
          echo "Frontend rollback triggered."

      # -----------------------------------------------------------------------
      # Wait for rollback to become live and verify health
      # -----------------------------------------------------------------------
      - name: Wait for rollback to propagate
        run: |
          echo "Waiting 120 s for Render to complete rollback deploys..."
          sleep 120

      - name: Verify backend health after rollback
        run: |
          MAX_ATTEMPTS=10
          ATTEMPT=0
          until [ $ATTEMPT -ge $MAX_ATTEMPTS ]; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              "${{ secrets.PROD_API_URL }}/health" 2>/dev/null) || STATUS="000"
            echo "Attempt $((ATTEMPT+1))/${MAX_ATTEMPTS}: backend health returned HTTP ${STATUS}"
            if [ "$STATUS" = "200" ]; then
              echo "Backend is healthy after rollback."
              exit 0
            fi
            ATTEMPT=$((ATTEMPT + 1))
            sleep 15
          done
          echo "::error::Backend did NOT recover after rollback. Immediate manual action required."
          exit 1

      - name: Verify frontend health after rollback
        run: |
          MAX_ATTEMPTS=10
          ATTEMPT=0
          until [ $ATTEMPT -ge $MAX_ATTEMPTS ]; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              "${{ secrets.PROD_FRONTEND_URL }}" 2>/dev/null) || STATUS="000"
            echo "Attempt $((ATTEMPT+1))/${MAX_ATTEMPTS}: frontend health returned HTTP ${STATUS}"
            if [ "$STATUS" = "200" ]; then
              echo "Frontend is healthy after rollback."
              exit 0
            fi
            ATTEMPT=$((ATTEMPT + 1))
            sleep 15
          done
          echo "::error::Frontend did NOT recover after rollback. Immediate manual action required."
          exit 1

      - name: Rollback complete
        run: |
          echo "Rollback to last known-good deploy completed successfully."
          echo "Failed version: ${{ needs.validate.outputs.version }}"
          echo "Both services are healthy at their previous deploy."

  # ===========================================================================
  # Notify Success
  # ===========================================================================
  notify-success:
    name: Deployment Complete
    runs-on: ubuntu-latest
    needs: [validate, smoke-tests]
    if: success()
    timeout-minutes: 5

    steps:
      - name: Production deployment successful
        run: |
          echo "Production deployment successful!"
          echo "Version: ${{ needs.validate.outputs.version }}"
          echo "URL: https://electricity-optimizer.com"
